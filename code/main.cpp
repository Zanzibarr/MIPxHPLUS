/**
 * @file main.cpp
 * @brief Main program for the hplus master thesis project
 *
 * @author Matteo Zanella <matteozanella2@gmail.com>
 * Copyright 2025 Matteo Zanella
 */

#include <sys/stat.h>  // For stat buffer {}
#include <termios.h>   // For CLI signal output manipulation
#include <unistd.h>    // For STDIN_FILENO

#include <csignal>  // For signal()
#include <thread>   // For thread operations

#include "algorithms.hpp"
#include "args.hxx"  // For args::ArgumentParser, ...

volatile int global_terminate{0};

static void signal_callback_handler([[maybe_unused]] const int signum) {
    if (global_terminate) exit(1);
    global_terminate = 1;
}

static void* time_limit_termination(void* args) {
    const auto* env{static_cast<hplus::environment*>(args)};
    while (env->exec_s < exec_status::STOP_TL && env->sol_s != solution_status::INFEAS) {
        if (env->timer.get_time() > static_cast<double>(env->time_limit)) [[unlikely]] {
            raise(SIGINT);
            return nullptr;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    return nullptr;
}

static void parse_cli(const int& argc, const char** argv, hplus::environment& env) {
    args::ArgumentParser parser("Find a solution / the optimal solution to the deletefree relaxation of any SAS+ planning task.",
                                "Copyright 2025 Matteo Zanella, Domenico Salvagnin");
    args::HelpFlag help(parser, "help", "Display the help menu", {"h", "help"});
    args::Positional<std::string> input_file(parser, "input_file", "Specify the input file (a .sas file provided by the FastDownward translator).");
    args::ValueFlag<std::string> logname(
        parser, "log_name",
        "Specify the name of the log file (will be located inside the logs/output_logs folder); if this is missing no log will be written.",
        {"l", "log"});
    args::ValueFlag<std::string> runname(
        parser, "run_name",
        "Specify the name of the run that will be shown in the log file as well as the log/lp files generated by cplex (def: '" +
            std::string(HPLUS_DEF_RUN_NAME) + "').",
        {"run"}, HPLUS_DEF_RUN_NAME);
    args::ValueFlag<bool> write_lp(parser, "0/1",
                                   "Write the lp file (def: " + std::to_string(HPLUS_DEF_WRITE_LP) + "; options: 0 (false), 1 (true)).", {"lp"},
                                   HPLUS_DEF_WRITE_LP);
    args::ValueFlag<std::string> algorithm(parser, "alg_name",
                                           "Specify the algorithm to use (def: " + std::string(HPLUS_DEF_ALG) +
                                               "; options: " + std::string(HPLUS_CLI_ALG_HEUR) + ", " + std::string(HPLUS_CLI_ALG_TL) + ", " +
                                               std::string(HPLUS_CLI_ALG_VE) + ", " + std::string(HPLUS_CLI_ALG_LM) + ").",
                                           {"a", "alg"}, HPLUS_DEF_ALG);
    args::ValueFlag<int> timelimit(parser, "int",
                                   "Specify the time limit in seconds (def: " + std::to_string(HPLUS_DEF_TIME_LIMIT) +
                                       "; options: >0 (set that as time limit)/<0 (no time limit)).",
                                   {"t", "time"}, HPLUS_DEF_TIME_LIMIT);
    args::ValueFlag<bool> preprocessing(
        parser, "0/1", "Perform preprocessing on the instance (def: " + std::to_string(HPLUS_DEF_PREP) + "; options: 0 (false), 1 (true)).", {"prep"},
        HPLUS_DEF_PREP);
    args::ValueFlag<std::string> heur(parser, "heur_name",
                                      "Specify which heuristic to compute before running cplex (def: " + std::string(HPLUS_DEF_HEUR) +
                                          "; options: none, " + std::string(HPLUS_CLI_HEUR_GREEDYCOST) + ", " +
                                          std::string(HPLUS_CLI_HEUR_GREEDYCXE) + ", " + std::string(HPLUS_CLI_HEUR_GREEDYHMAX) + ", " +
                                          std::string(HPLUS_CLI_HEUR_GREEDYHADD) + ").",
                                      {"heur"}, HPLUS_DEF_HEUR);
    args::ValueFlag<bool> warmstart(
        parser, "0/1",
        "Using the heuristic (if computed) as warm start (def: " + std::to_string(HPLUS_DEF_WARM_START) + "; options: 0 (false), 1 (true)).", {"ws"},
        HPLUS_DEF_WARM_START);
    args::ValueFlag<bool> tightbounds(parser, "0/1",
                                      "Using tighter bounds (def: " + std::to_string(HPLUS_DEF_TIGHT_BOUNDS) + "; options: 0 (false), 1 (true)).",
                                      {"tb"}, HPLUS_DEF_TIGHT_BOUNDS);
    args::ValueFlag<bool> minimal_lm(
        parser, "0/1", "Using minimal landmarks as cuts for the lm model (def: " + std::to_string(HPLUS_DEF_MLM) + "; options: 0 (false), 1 (true)).",
        {"mlm"}, HPLUS_DEF_MLM);
    args::ValueFlag<bool> complete_lm(
        parser, "0/1",
        "Using complete landmarks as cuts for the lm model (def: " + std::to_string(HPLUS_DEF_CLM) + "; options: 0 (false), 1 (true)).", {"clm"},
        HPLUS_DEF_CLM);
    args::ValueFlag<bool> sec(parser, "0/1",
                              "Using S.E.C. as cuts for the lm model (def: " + std::to_string(HPLUS_DEF_SEC) + "; options: 0 (false), 1 (true)).",
                              {"sec"}, HPLUS_DEF_SEC);
    args::ValueFlag<bool> fract(
        parser, "0/1",
        "Using fractionary solutions to generate cuts for the lm model (def: " + std::to_string(HPLUS_DEF_FRACT) + "; options: 0 (false), 1 (true)).",
        {"fract"}, HPLUS_DEF_FRACT);

    try {
        parser.ParseCLI(argc, argv);
    } catch (const args::Help&) {
        std::cout << parser;
        exit(0);
    } catch (const args::ParseError& e) {
        std::cerr << e.what() << std::endl;
        std::cerr << parser;
        exit(1);
    }

    if (!input_file) {
        std::cerr << "MISSING INPUT FILE.\n";
        exit(1);
    } else
        env.input_file = args::get(input_file);
    struct stat buffer{};
    if (stat((env.input_file).c_str(), &buffer) != 0) {
        std::cerr << "Failed to open input file.\n";
        exit(1);
    }
    if (logname) {
        env.log = true;
        env.log_name = args::get(logname);
    }
    if (runname) env.run_name = args::get(runname);
    if (write_lp) env.write_lp = args::get(write_lp);

    if (algorithm) env.alg = args::get(algorithm);
    if (timelimit) {
        const int tl{args::get(timelimit)};
        env.time_limit = (tl < 0) ? std::numeric_limits<unsigned int>::max() : tl;
    }
    if (preprocessing) env.preprocessing = args::get(preprocessing);
    if (heur) env.heur = args::get(heur);
    if (warmstart) env.warm_start = args::get(warmstart);
    if (tightbounds) env.tight_bounds = args::get(tightbounds);
    if (minimal_lm) env.minimal_landmark = args::get(minimal_lm);
    if (complete_lm) env.complete_landmark = args::get(complete_lm);
    if (sec) env.sec = args::get(sec);
    if (fract) env.fract_cuts = args::get(fract);

    if (env.alg != HPLUS_CLI_ALG_TL && env.alg != HPLUS_CLI_ALG_VE && env.alg != HPLUS_CLI_ALG_LM) {
        env.write_lp = false;
        env.using_cplex = false;
        env.warm_start = false;
        env.tight_bounds = false;
    }
    if (env.alg == HPLUS_CLI_ALG_LM && !env.minimal_landmark && !env.complete_landmark && !env.sec) {
        std::cout << "You cannot disable all minimal, complete landmarks and sec from the lm model.\n";
        exit(1);
    }
    if (env.warm_start && env.heur == "none") {
        ACK_REQ("Warm start has been activated but heuristic has been disabled: disabling warm start");
        env.warm_start = false;
    }
}

static void show_info(const hplus::instance& inst, const hplus::environment& env, const logger& log) {
    PRINT_VERBOSE(log, "Showing info about the execution.");
#if HPLUS_VERBOSE < 1
    return;
#endif

    log.print(LINE);

    std::time_t time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    log.print("%sCode version: %s.\n%s", std::ctime(&time), CODE_VERSION, LINE);
    log.print("Input file: %47s.", env.input_file.c_str());
    if (env.log && !env.log_name.empty()) log.print("Log name: %49s.", env.log_name.c_str());
    if (!env.run_name.empty()) log.print("Run name:          %40s.", env.run_name.c_str());
    if (env.write_lp) log.print("Writing lp file.");
    log.print("Verbose parameter:                               %10d.", HPLUS_VERBOSE);
    log.print("Warnings parameter:                              %10d.", HPLUS_WARN);
    log.print("Integrity checks parameter:                      %10d.", HPLUS_INTCHECK);

    log.print(LINE);

    log.print("Metric:                                %20s.",
              (inst.equal_costs ? (inst.actions[0].cost == 1 ? "unitary costs" : "constant costs") : "integer costs"));
    log.print("# facts:                                         %10d.", inst.n);
    log.print("# actions:                                       %10d.", inst.m);

    log.print(LINE);

#if HPLUS_INTCHECK
    log.print(
        "\033[1m!!  Integrity checks enabled (execution might be slower)  "
        "!!\033[0m");
    log.print(LINE);
#endif

    log.print("Algorithm:                                       %10s.", env.alg.c_str());
    log.print("Preprocessing:                                   %10s.", env.preprocessing ? "Y" : "N");
    log.print("Tighter bounds:                                  %10s.", env.tight_bounds ? "Y" : "N");
    if (env.heur != "none") log.print("Heuristic:                                       %10s.", env.heur.c_str());
    if (env.using_cplex) log.print("Warm start:                                      %10s.", env.warm_start ? "Y" : "N");
    if (env.alg == HPLUS_CLI_ALG_LM) {
        log.print("Minimal landmarks:                               %10s", env.minimal_landmark ? "Y" : "N");
        log.print("Complete landmarks:                              %10s", env.complete_landmark ? "Y" : "N");
        log.print("S.E.C.:                                          %10s", env.sec ? "Y" : "N");
    }
    log.print("Time limit:                                     %10us.", env.time_limit);
    log.print(LINE);
}

static void run(hplus::instance& inst, hplus::environment& env, hplus::statistics& stats, const logger& log) {
    PRINT_VERBOSE(log, "Executing the chosen algorithms.");

    try {
        double start_time;
        if (env.alg != HPLUS_CLI_ALG_TL && env.alg != HPLUS_CLI_ALG_VE && env.alg != HPLUS_CLI_ALG_LM && env.alg != HPLUS_CLI_ALG_HEUR)

            log.raise_error("The algorithm specified (%s) is not on the list of possible algorithms... Please use the --h flag for instructions.",
                            env.alg.c_str());

        auto stopchk = [&env]() {
            if (CHECK_STOP()) {
                env.exec_s = exec_status::STOP_TL;
                throw timelimit_exception("Reached time limit.");
            }
        };

        // ~~~~~~~~~~~~ PREPROCESSING ~~~~~~~~~~~~ //

        if (env.preprocessing) {
            PRINT_INFO(log, "Preprocessing.");
            env.exec_s = exec_status::PROBLEM_SIMPL;

            stats.preprocessing = static_cast<double>(env.time_limit) - env.timer.get_time();
            start_time = env.timer.get_time();

            hplus::preprocessing(inst, log);

            stats.preprocessing = env.timer.get_time() - start_time;
        }
        stopchk();

        hplus::prepare_faster_actsearch(inst, log);

        // ~~~~~~~~~~~~~~ HEURISTIC ~~~~~~~~~~~~~~ //

        if (env.heur != "none" || env.alg == HPLUS_CLI_ALG_HEUR) {
            if (env.heur != HPLUS_CLI_HEUR_GREEDYCOST && env.heur != HPLUS_CLI_HEUR_GREEDYCXE && env.heur != HPLUS_CLI_HEUR_GREEDYHMAX &&
                env.heur != HPLUS_CLI_HEUR_GREEDYHADD) {
                log.raise_error("The heuristic specified (%s) is not on the list of possible heuristics... Please use the --h flag for instructions.",
                                env.heur.c_str());
            }

            PRINT_INFO(log, "Calculating heuristic solution.");
            env.exec_s = exec_status::HEURISTIC;

            stats.heuristic = static_cast<double>(env.time_limit) - env.timer.get_time();
            start_time = env.timer.get_time();

            run_heur(inst, env, log);
            if (env.sol_s != solution_status::INFEAS) {
                stats.hcost = inst.best_sol.cost;
                stats.fcost = inst.best_sol.cost;
            }

            stats.heuristic = env.timer.get_time() - start_time;
        }
        stopchk();

        if (env.sol_s == solution_status::INFEAS) return;

        if (env.alg == HPLUS_CLI_ALG_HEUR) {
            env.exec_s = exec_status::STOP_TL;
            return;
        }

        run_model(inst, env, stats, log);
        stats.fcost = inst.best_sol.cost;

    } catch (timelimit_exception&) {
    }
}

static void end(const hplus::instance& inst, hplus::environment& env, hplus::statistics& stats, const logger& log) {
    if (env.timer.get_time() >= static_cast<double>(env.time_limit)) {
        switch (env.exec_s) {
            case exec_status::START:
                log.print("Reached time limit before the program could read the instance file.");
                break;
            case exec_status::READ_INPUT:
                log.print("Reached time limit while parsing the instance file.");
                break;
            case exec_status::PROBLEM_SIMPL:
                log.print("Reached time limit while simplificating the problem.");
                break;
            case exec_status::HEURISTIC:
                log.print(
                    "Reached time limit while calculating an heuristic "
                    "solution.");
                break;
            case exec_status::MODEL_BUILD:
                log.print("Reached time limit while building the model.");
                break;
            case exec_status::CPX_EXEC:
                log.print("Reached time limit during CPLEX's execution.");
                break;
            default:
                break;
        }
    }

    env.exec_s = exec_status::EXIT;

    switch (env.sol_s) {
        case solution_status::INFEAS:
            log.print("The problem is infeasible.");
            stats.status = 1;
            break;
        case solution_status::NOTFOUND:
            log.print("No solution found.");
            stats.status = 3;
            break;
        case solution_status::FEAS:
            log.print("The solution has not been proven optimal.");
            stats.status = 2;
            hplus::print_sol(inst, log);
            break;
        case solution_status::OPT:
            stats.status = 0;
            hplus::print_sol(inst, log);
            break;
        default:
            stats.status = -1;
            break;
    }

    stats.total = env.timer.get_time();
    hplus::print_stats(stats, log);
}

int main(const int argc, const char** argv) {
    signal(SIGINT, signal_callback_handler);
    struct termios t{};
    tcgetattr(STDIN_FILENO, &t);
    t.c_lflag &= ~ECHOCTL;
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &t);
    hplus::instance inst;
    hplus::environment env;
    hplus::init(env);
    hplus::statistics stats;
    hplus::init(stats);
    parse_cli(argc, argv, env);
    logger log(env.log, HPLUS_LOG_DIR "/" + env.log_name, env.run_name);
    pthread_t timer_thread;
    pthread_create(&timer_thread, nullptr, time_limit_termination, &env);
    if (hplus::create_instance(inst, env, stats, log)) {
        show_info(inst, env, log);
        run(inst, env, stats, log);
    }
    env.exec_s = exec_status::EXIT;
    pthread_join(timer_thread, nullptr);
    end(inst, env, stats, log);
}