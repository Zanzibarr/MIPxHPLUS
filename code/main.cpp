/**
 * @file main.cpp
 * @brief Main program for the hplus master thesis project
 *
 * @author Matteo Zanella <matteozanella2@gmail.com>
 * Copyright 2025 Matteo Zanella
 */

#include <sys/stat.h>  // For stat buffer {}
#include <termios.h>   // For CLI signal output manipulation
#include <unistd.h>    // For STDIN_FILENO

#include <csignal>  // For signal()
#include <thread>   // For thread operations

#include "algorithms.hpp"
#include "args.hxx"  // For args::ArgumentParser, ...

volatile int global_terminate{0};

static void signal_callback_handler([[maybe_unused]] const int signum) {
    if (global_terminate) exit(1);
    global_terminate = 1;
}

static void* time_limit_termination(void* args) {
    const auto* env{static_cast<hplus::environment*>(args)};
    while (env->exec_s < exec_status::STOP_TL && env->sol_s != solution_status::INFEAS) {
        if (env->timer.get_time() > static_cast<double>(env->time_limit)) [[unlikely]] {
            raise(SIGINT);
            return nullptr;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    return nullptr;
}

static void init(hplus::environment& env) {
    env = hplus::environment{.exec_s = exec_status::START,
                             .sol_s = solution_status::NOTFOUND,
                             .input_file = "N/A",
                             .log_name = HPLUS_LOG_DIR "/hplus_log.log",
                             .run_name = "UnnamedRun",
                             .alg = HPLUS_CLI_ALG_RANKOOH,
                             .heur = "hadd",
                             .preprocessing = true,
                             .warm_start = true,
                             .tight_bounds = false,
                             .using_cplex = true,
                             .log = false,
                             .write_lp = false,
                             .time_limit = 60,
                             .timer = time_keeper()};
}

static void init(hplus::statistics& stats) {
    stats = hplus::statistics{.parsing = 0,
                              .preprocessing = 0,
                              .heuristic = 0,
                              .build = 0,
                              .callback = 0,
                              .execution = 0,
                              .total = 0,
                              .callback_time_mutex = PTHREAD_MUTEX_INITIALIZER,
                              .hcost = -1,
                              .fcost = -1,
                              .nnodes = -1,
                              .status = -1,
                              .nvar_base = -1,
                              .nvar_acyclic = -1,
                              .nconst_base = -1,
                              .nconst_acyclic = -1,
                              .nusercuts = -1,
                              .lb = -1};
}

static void parse_cli(const int& argc, const char** argv, hplus::environment& env) {
    args::ArgumentParser parser("Find a solution / the optimal solution to the deletefree relaxation of any SAS+ planning task.",
                                "Copyright 2025 Matteo Zanella, Domenico Salvagnin");
    args::HelpFlag help(parser, "help", "Display the help menu", {"h", "help"});
    args::Positional<std::string> input_file(parser, "input_file", "Specify the input file (a .sas file provided by the FastDownward translator).");
    args::ValueFlag<std::string> logname(
        parser, "log_name",
        "Specify the name of the log file (will be located inside the logs/output_logs folder); if this is missing no log will be written.",
        {"l", "log"});
    args::ValueFlag<std::string> runname(
        parser, "run_name",
        "Specify the name of the run that will be shown in the log file as well as the log/lp files generated by cplex (def: 'UnnamedRun').", {"run"},
        "UnnamedRun");
    args::ValueFlag<bool> write_lp(parser, "0/1", "Write the lp file (def: false; options: 0 (false), 1 (true)).", {"lp"}, false);
    args::ValueFlag<std::string> algorithm(parser, "alg_name", "Specify the algorithm to use (def: rankooh; options: heur, imai, rankooh, dynamic).",
                                           {"a", "alg"}, HPLUS_CLI_ALG_RANKOOH);
    args::ValueFlag<int> timelimit(parser, "int", "Specify the time limit (def: 60; options: >0 (set that as time limit)/<0 (no time limit)).",
                                   {"t", "time", "tl"}, 60);
    args::ValueFlag<bool> preprocessing(parser, "0/1", "Perform preprocessing on the instance (def: true; options: 0 (false), 1 (true)).", {"prep"},
                                        true);
    args::ValueFlag<std::string> heur(parser, "heur_name",
                                      "Specify which heuristic to compute before running cplex (def: hadd; options: none, greedycost, greedycxe, "
                                      "hmax, hadd).",
                                      {"heur"}, "hadd");
    args::ValueFlag<bool> warmstart(parser, "0/1", "Using (if computed) the heuristic as warm start (def: true; options: 0 (false), 1 (true)).",
                                    {"ws"}, true);
    args::ValueFlag<bool> tightbounds(parser, "0/1", "Using tighter bounds (def: false; options: 0 (false), 1 (true)).", {"tb"}, false);

    try {
        parser.ParseCLI(argc, argv);
    } catch (const args::Help&) {
        std::cout << parser;
        exit(0);
    } catch (const args::ParseError& e) {
        std::cerr << e.what() << std::endl;
        std::cerr << parser;
        exit(1);
    }

    if (!input_file) {
        std::cerr << "MISSING INPUT FILE.\n";
        exit(1);
    } else
        env.input_file = args::get(input_file);
    struct stat buffer{};
    if (stat((env.input_file).c_str(), &buffer) != 0) {
        std::cerr << "Failed to open input file.\n";
        exit(1);
    }
    if (logname) {
        env.log = true;
        env.log_name = args::get(logname);
    }
    if (runname) env.run_name = args::get(runname);
    if (write_lp) env.write_lp = args::get(write_lp);

    if (algorithm) env.alg = args::get(algorithm);
    if (timelimit) {
        const int tl{args::get(timelimit)};
        env.time_limit = (tl < 0) ? std::numeric_limits<unsigned int>::max() : tl;
    }
    if (preprocessing) env.preprocessing = args::get(preprocessing);
    if (heur) env.heur = args::get(heur);
    if (warmstart) env.warm_start = args::get(warmstart);
    if (tightbounds) env.tight_bounds = args::get(tightbounds);

    if (env.alg != HPLUS_CLI_ALG_IMAI && env.alg != HPLUS_CLI_ALG_RANKOOH && env.alg != HPLUS_CLI_ALG_DYNAMIC_TIME) {
        env.write_lp = false;
        env.using_cplex = false;
        env.warm_start = false;
        env.tight_bounds = false;
    }
    if (env.warm_start && env.heur == "none") {
        ACK_REQ("Warm start has been activated but heuristic has been disabled: disabling warm start");
        env.warm_start = false;
    }
}

static void show_info(const hplus::instance& inst, const hplus::environment& env, const logger& log) {
    PRINT_VERBOSE(log, "Showing info about the execution.");
#if HPLUS_VERBOSE < 1
    return;
#endif

    if (env.preprocessing && env.tight_bounds)
        PRINT_WARN(log, "Immediate action application might mess up with the tight bounds analysis: removed immediate application analysis.");

    log.print(LINE);

    std::time_t time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    log.print("%sCode version: %s.\n%s", std::ctime(&time), CODE_VERSION, LINE);
    log.print("Input file: %47s.", env.input_file.c_str());
    if (env.log && !env.log_name.empty()) log.print("Log name: %49s.", env.log_name.c_str());
    if (!env.run_name.empty()) log.print("Run name:          %40s.", env.run_name.c_str());
    if (env.write_lp) log.print("Writing lp file.");
    log.print("Verbose parameter:                               %10d.", HPLUS_VERBOSE);
    log.print("Warnings parameter:                              %10d.", HPLUS_WARN);
    log.print("Integrity checks parameter:                      %10d.", HPLUS_INTCHECK);

    log.print(LINE);

    log.print("Metric:                                %20s.",
              (inst.equal_costs ? (inst.actions[0].cost == 1 ? "unitary costs" : "constant costs") : "integer costs"));
    log.print("# facts:                                         %10d.", inst.n);
    log.print("# actions:                                       %10d.", inst.m);

    log.print(LINE);

#if HPLUS_INTCHECK
    log.print(
        "\033[1m!!  Integrity checks enabled (execution might be slower)  "
        "!!\033[0m");
    log.print(LINE);
#endif

    log.print("Algorithm:                                       %10s.", env.alg.c_str());
    log.print("Preprocessing:                                   %10s.", env.preprocessing ? "Y" : "N");
    log.print("Tighter bounds:                                  %10s.", env.tight_bounds ? "Y" : "N");
    if (env.heur != "none") log.print("Heuristic:                                       %10s.", env.heur.c_str());
    if (env.using_cplex) log.print("Warm start:                                      %10s.", env.warm_start ? "Y" : "N");
    log.print("Time limit:                                     %10us.", env.time_limit);
    log.print(LINE);
}

static void run(hplus::instance& inst, hplus::environment& env, hplus::statistics& stats, const logger& log) {
    PRINT_VERBOSE(log, "Executing the chosen algorithms.");

    try {
        double start_time;
        if (env.alg != HPLUS_CLI_ALG_IMAI && env.alg != HPLUS_CLI_ALG_RANKOOH && env.alg != HPLUS_CLI_ALG_DYNAMIC_TIME &&
            env.alg != HPLUS_CLI_ALG_HEUR)

            log.raise_error("The algorithm specified (%s) is not on the list of possible algorithms... Please use the --h flag for instructions.",
                            env.alg.c_str());

        auto stopchk = [&env]() {
            if (CHECK_STOP()) {
                env.exec_s = exec_status::STOP_TL;
                throw timelimit_exception("Reached time limit.");
            }
        };

        // ~~~~~~~~~~~~ PREPROCESSING ~~~~~~~~~~~~ //

        if (env.preprocessing) {
            PRINT_INFO(log, "Preprocessing.");
            env.exec_s = exec_status::PROBLEM_SIMPL;

            stats.preprocessing = static_cast<double>(env.time_limit) - env.timer.get_time();
            start_time = env.timer.get_time();

            hplus::preprocessing(inst, env, log);

            stats.preprocessing = env.timer.get_time() - start_time;
        }
        stopchk();

        hplus::prepare_faster_actsearch(inst, log);

        // ~~~~~~~~~~~~~~ HEURISTIC ~~~~~~~~~~~~~~ //

        if (env.heur != "none" || env.alg == HPLUS_CLI_ALG_HEUR) {
            if (env.heur != "greedycost" && env.heur != "greedycxe" && env.heur != "hmax" && env.heur != "hadd") {
                log.raise_error("The heuristic specified (%s) is not on the list of possible heuristics... Please use the --h flag for instructions.",
                                env.heur.c_str());
            }

            PRINT_INFO(log, "Calculating heuristic solution.");
            env.exec_s = exec_status::HEURISTIC;

            stats.heuristic = static_cast<double>(env.time_limit) - env.timer.get_time();
            start_time = env.timer.get_time();

            run_heur(inst, env, log);
            if (env.sol_s != solution_status::INFEAS) {
                stats.hcost = inst.best_sol.cost;
                stats.fcost = inst.best_sol.cost;
            }

            stats.heuristic = env.timer.get_time() - start_time;
        }
        stopchk();

        if (env.sol_s == solution_status::INFEAS) return;

        if (env.alg == HPLUS_CLI_ALG_HEUR) {
            env.exec_s = exec_status::STOP_TL;
            return;
        }

        run_model(inst, env, stats, log);
        stats.fcost = inst.best_sol.cost;

    } catch (timelimit_exception&) {
    }
}

static void end(const hplus::instance& inst, hplus::environment& env, hplus::statistics& stats, const logger& log) {
    if (env.timer.get_time() >= static_cast<double>(env.time_limit)) {
        switch (env.exec_s) {
            case exec_status::START:
                log.print("Reached time limit before the program could read the instance file.");
                break;
            case exec_status::READ_INPUT:
                log.print("Reached time limit while parsing the instance file.");
                break;
            case exec_status::PROBLEM_SIMPL:
                log.print("Reached time limit while simplificating the problem.");
                break;
            case exec_status::HEURISTIC:
                log.print(
                    "Reached time limit while calculating an heuristic "
                    "solution.");
                break;
            case exec_status::MODEL_BUILD:
                log.print("Reached time limit while building the model.");
                break;
            case exec_status::CPX_EXEC:
                log.print("Reached time limit during CPLEX's execution.");
                break;
            default:
                break;
        }
    }

    env.exec_s = exec_status::EXIT;

    switch (env.sol_s) {
        case solution_status::INFEAS:
            log.print("The problem is infeasible.");
            stats.status = 1;
            break;
        case solution_status::NOTFOUND:
            log.print("No solution found.");
            stats.status = 3;
            break;
        case solution_status::FEAS:
            log.print("The solution has not been proven optimal.");
            stats.status = 2;
            hplus::print_sol(inst, log);
            break;
        case solution_status::OPT:
            stats.status = 0;
            hplus::print_sol(inst, log);
            break;
        default:
            stats.status = -1;
            break;
    }

    stats.total = env.timer.get_time();
    hplus::print_stats(stats, log);
}

#ifndef HPLUS_INFO
int main(const int argc, const char** argv) {
    signal(SIGINT, signal_callback_handler);
    struct termios t{};
    tcgetattr(STDIN_FILENO, &t);
    t.c_lflag &= ~ECHOCTL;
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &t);
    hplus::instance inst;
    hplus::environment env;
    init(env);
    hplus::statistics stats;
    init(stats);
    parse_cli(argc, argv, env);
    logger log(env.log, HPLUS_LOG_DIR "/" + env.log_name, env.run_name);
    pthread_t timer_thread;
    pthread_create(&timer_thread, nullptr, time_limit_termination, &env);
    if (hplus::create_instance(inst, env, stats, log)) {
        show_info(inst, env, log);
        run(inst, env, stats, log);
    }
    env.exec_s = exec_status::EXIT;
    pthread_join(timer_thread, nullptr);
    end(inst, env, stats, log);
}
#endif