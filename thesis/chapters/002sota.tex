To build a MIP formulation that solves the delete-relaxed task $\Pi^+$, we identify two sections:
\begin{enumerate}
    \item Base IP model: defining variables for atoms, actions and \textit{first achievers} \cite{Imai_15}, aswell as a basic set of constraints, aiming to enforce the basic functionalities of actions;
    \item Modeling acyclicity: ensuring that the solution is in fact a plan, by adding constraints that make sure that a timeline of actions can be constructed from the solution obtained by the MIP solver.
\end{enumerate}
The straightforward IP models, proposed by the literature, are often intractable and not useful in practice for computing $\hplus$; this has lead the research community to develop preprocessing techniques to reduce the size and complexity of the IP models.

\section{Base IP model}
Different models have been proposed in past years; we will use the base model proposed in \cite{Rankooh_22}:\\
$x_a\in\{0,1\}$ indicates whether the action $a$ is used in a solution $\pi$.
$$x_a=
\begin{cases}
    0\qquad\mbox{if }a\not\in\pi\\
    1\qquad\mbox{if }a\in\pi
\end{cases}\forall a\in A^+
$$
$x_p\in\{0,1\}$ indicates whether an atom $p$ is achieved in a solution $\pi$.
$$x_p=
\begin{cases}
    0\qquad\mbox{if }p\not\in I(\pi)\\
    1\qquad\mbox{if }p\in I(\pi)
\end{cases}\forall p\in P
$$
$x_{a,p}\in\{0,1\}$ indicates whether $a$ is the first achiever of $p$.
$$x_{a,p}=
\begin{cases}
    1\qquad\mbox{if }a\mbox{ is the first achiever of }p\\
    0\qquad\mbox{otherwise}
\end{cases}\forall a\in A^+,\forall p\in \mbox{add}(a)
$$
Having defined the variables that will be used in our formulation, the model is defined as follows:
$$
\begin{cases}
    \displaystyle\min\sum_{ a\in A^+}x_a\cdot cost(a)\\
    \displaystyle_{(C1)}\quad\sum_{a\in A^+_p}x_{a,p}=x_p&\forall p\in P,\,A^+_p=\{a\in A^+,\,s.t.\,p\in \mbox{add}(a)\}\\
    \displaystyle_{(C2)}\quad\sum_{a\in A^+_{p,q}}x_{a,q}\leq x_p&\forall p,q\in P,\,A^+_{p,q}=\{a\in A^+,\,s.t.\,p\in \mbox{pre}(a),q\in \mbox{add}(a)\}\\
    _{(C3)}\quad x_{a,p}\leq x_a&\forall a\in A^+,\,p\in \mbox{add}(a)\\
    _{(C4)}\quad x_p=1&\forall p\in G
\end{cases}
$$

\begin{enumerate}
    \item[]$(C1)$: An atom is achieved iff an action is its first achiever; moreover there can be only one first achiever per atom;
    \item[]$(C2)$: An action can be a first achiever only if its preconditions are achieved;
    \item[]$(C3)$: An action can be a first achiever only if it's used;
    \item[]$(C4)$: Each atom in the goal state is achieved;
\end{enumerate}
Note that, since there's no upper bound on action indicator variables, 0-cost actions might be flagged as used, even if they aren't, and still be a plan with optimal cost.\\
If we were just looking for the optimal cost $c^*$, this wouldn't bother us; however, since we are interested in the optimal plan $\pi^*$, we must acknowledge those actions by filtering the solution obtained by removing actions that aren't first achiever of any atom.

\section{Modeling acyclicity}
As shown both in \cite{Imai_15} and \cite{Rankooh_22}, any solution $\pi$ needs to be acyclic for it to be a plan, hence the need to add variables and constraints to force such acyclicity in the base model.\\
Multiple methods have been proposed: the time labeling method was first proposed in \cite{Imai_15} while vertex elimination was proposed in \cite{Rankooh_22}; the latter, however, proposed a revised time labeling method, proving that it was better than its predecessor, hence we will only mention the improved version.

\subsection{Time labeling}
For the time labeling method, we just need to create for each atom $p$, a timestamp $t_p\in\{0,...,|A^+|\}$.\\
The constraints to add to the model will then be:
$$_{(C5)}\quad t_p + 1 \leq t_q + |P|(1-x_{a, q})\qquad\forall a\in A^+,p\in \mbox{pre}(a),q\in \mbox{add}(a)$$
This constraint reads: if $a$ is first achiever of $q$, then every $p\in \mbox{pre}(a)$ must have a timestamp that precedes than $q$.

The correctness of this model is implied from its construction, having tackled directly the problem of having to construct a timeline of actions out of the obtained solution with constraint ${(C5)}$.

\subsection{Vertex elimination graph}
To explain how to use a vertex elimination graph to model acyclicity, we first need to define a \textit{causal relation graph} \cite{Rankooh_22_2}.
A causal relation graph of $\Pi^+$ is $G_{\Pi^+}=(P,E_{\Pi^+}),\mbox{ where }E_{\Pi^+}=\{(p,q),\,s.t.\,\exists a\in A^+\mbox{ with }p\in \mbox{pre}(a),q\in \mbox{add}(a)\}$.
As shown in \cite{Rankooh_22}, let $\mathcal{O}$ be an elimination ordering for $G_{\Pi^+}$, and $G^*_{\Pi^+}=(P,E^*_{\Pi^+})$ be the vertex elimination graph of $G_{\Pi^+}$ according to $\mathcal{O}$. Let $\Delta$ be the set of all triangles produced by elimination ordering $\mathcal{O}$ for graph $G_{\Pi^+}$: members of $\Delta$ are all ordered triples $(p,q,r)\,s.t.\,(p,r)$ is added to $E^*_{\Pi^+}$ by eliminating $q$.\\
We then create a variable for each edge $(p,q)\in E^*_{\Pi^+}$, $e_{p,q}\in\{0,1\}\,\forall (p,q)\in E^*_{\Pi^+}$ and add the following constraints:
$$
\begin{cases}
    _{(C6)}\quad x_{a,q}\leq e_{p,q}&\forall a\in A^+,p\in \mbox{pre}(a),q\in \mbox{add}(a)\\
    _{(C7)}\quad e_{p,q}+e_{q,p}\leq 1&\forall(p,q)\in E^*_{\Pi^+}\\
    _{(C8)}\quad e_{p,q}+e_{q,r}-1\leq e_{p,r}&\forall(p,q,r)\in\Delta
\end{cases}
$$
The correctness of the resulting model, composed of constraints $(C1)$ to $(C4)$ and $(C6)$ to $(C9)$, is proved in \cite{Rankooh_22}.

We will identify the two formulations respectively $\tl$ and $\ve$.

\section{Preprocessing}
\subsection{Landmark-based model reduction}
A \textit{landmark} is an element which needs to be used in every feasible solution \cite{Hoffman_04}. We define \textit{fact landmarks} and \textit{action landmarks}, as in \cite{Gefen_12}: a fact landmark of a planning task $\Pi$ is an atom that becomes true in some state of every plan, and similarly, an action landmark of a planning task $\Pi$ is an action that is included in every plan. Moreover, a fact or action landmark $l$ if a landmark for an atom $p$ if $l$ is a landmark for the task $(P,A,I,\{p\},cost)$, and similarly, $l$ is a landmark for an action $a$ if $l$ is a landmark for the task $(P,A,I,\mbox{pre}(a),cost)$.
For our delete-relaxed task $\Pi^+$, this leads to an obvious simplification of our model:
$$_{(P1)}\quad x_p,x_a\equiv1\qquad\forall p\in P,a\in A^+\mbox{ that is a fact/action landmark for (an atom in) }G$$

We can easily find a fact landmark $p$ or an action landmark $a$ by checking wether $(P,A^+\setminus A^+_p,I,G,cost)$, with $A^+_p=\{a\in A^+,\,s.t.\;p\in \mbox{add}(a)\}$, or $(P,A^+\setminus \{a\},I,G,cost)$ respectively, are infeasible tasks; however, since this is algorithm will be accompanied by other, more powerful, preprocessing techniques, we opted for the efficient extraction method, which however doesn't compute all landmarks, proposed in \cite{Imai_15}:
\begin{algorithm}[h]
    \caption{Efficient landmark extracion algorithm}
    \begin{algorithmic}
        \State $L[p]\gets P\mbox{ for each } p\in P$ \qquad \# $L[p]$ stores candidates of fact landmarks for $p\in P$
        \State $S\gets\emptyset$
        \For{$a\in A^+$}
            \State $\mbox{insert }a\mbox{ into a FIFO queue }Q\mbox{ if }\mbox{pre}(a)\subseteq S$
        \EndFor
        \While{$Q\not=\emptyset$}
            \State retrieve an action $a$ from $Q$
            \For{$p\in \mbox{add}(a)$}
                \State $S\gets S\cup\{p\}$
                \State $X\gets L[p]\cap(\mbox{add}(a)\cup\bigcup_{p'\in \mbox{pre}(a)}L[p'])$
                \If{$L[p]\not= X$}
                    \State $L[p]\gets X$
                    \For{$a'\in\{a\in A^+,\,s.t.\;p\in \mbox{pre}(a)\}$}
                    \State insert $a'$ into $Q$ if $pre(a')\subseteq S$ and $a'\not\in Q$
                    \EndFor
                \EndIf
            \EndFor
        \EndWhile
        \State \# Now $L[p]$ contains the set of fact landmarks for $p\in P$
    \end{algorithmic}
\end{algorithm}

We conclude our landmark-based model reduction by extracting action landmarks as follows: if an atom $p$ is a fact landmark for $G$, and if only one action $a$ can achieve $p$, then $a$ is an action landmark for $G$.

\subsection{First achievers filtering}
In \cite{LB_Haslum_12}, a first achiever is defined by achievability of a proposition; however, we can check wether an action \textit{can} be a first achiever of an atom, and remove variables associated to those who can't \cite{Imai_15}: an action $a$ is a first achiever of a proposition $p$ if $p\in \mbox{add}(a)$ and $p$ is not a fact landmark for $a$.
We can use this concept fo strenghten future preprocessing techniques: we define $\mbox{fadd}(a)=\{p\in \mbox{add}(a),\,s.t.\;p\mbox{ is not a fact landmark for }a\}$.
We can also use this new definition of first achievers to remove some variables from our formulation:
$$_{(P2)}\quad x_{a,p}\equiv0\qquad\forall a\in A^+,p\in \mbox{add}(a),\,s.t.\;p\mbox{ is a fact landmark for }a$$

\subsection{Relevance analysys}
Relevance analysis is widely used to eliminate atoms and actions that are irrelevant to a task. In \cite{Imai_15}, a backchaining relevance analysis is proposed, where an action $a$ is relevant if $\mbox{fadd}(a)\cap G\not=\emptyset$ or there exists a relevant action $a'$ satisfying $\mbox{fadd}(a)\cap pre(a')\not=\emptyset$, and an atom $p$ is relevant if $p\in G$ or there exists a relevant action $a$ with $p\in \mbox{pre}(a)$.
In \cite{MLM_Haslum_12}, this relevance analysis is strenghtened by considering as relevant only actions that are possible first achievers of a relevant atom ($\mbox{fadd}(a)\cap\{p\in P,\,s.t.\;p\mbox{ is relevant}\}\not=\emptyset$).
Actions and atoms that aren't relevant, can be removed from our formulation:
$$_{(P3)}\quad x_a,x_p\equiv0\qquad\forall a\in A^+,p\in P,\mbox{ that isn't relevant}$$
As noted in \cite{Imai_15}, a fact landmark might be found not relevant: in this case we just set $x_p\equiv1$.

\subsection{Dominated actions extraction}
In a delete-relaxed task, if two actions have the same positive effects, it's clearly sufficient to use at most one of those two actions \cite{Imai_15}: given a feasible delete-relaxed task $\Pi^+$, there exists an optimal plan that doesn't contain $b\in A^+$ if there exists an action $a\in A^+$ satisfying $(\mbox{fadd}(b)\subseteq fadd(a)$ and $\forall p\in pre(a),\;p\mbox{ is a fact landmark for }b$ and $cost(b)\geq cost(a))$, and we call such $b$ as a \textit{dominated action}.
$$_{(P4)}\quad x_a\equiv0\qquad\forall a\in A^+\mbox{ that is a dominated action}$$
This constraint might prune feasible, even some optimal, solutions, but as it's shown in \cite{Imai_15} at least one optimal solution remains. 

\subsection{Inverse actions extraction}
For two actions $a,b\in A^+$, $a$ is an \textit{inverse action} of $b$ if $\mbox{add}(a)\subseteq pre(b)$ and $add(b)\subseteq \mbox{pre}(a)$.
Clearly, if $a$ is an inverse action of $b$, then $b$ must be an inverse action of $a$.\\
For a delete-relaxed task $\Pi^+$, if $a,b\in\pi$ and $a$ is an inverse action of $b$, then there exist a feasible plan $\pi'$ with at most one of $a$ and $b$ in it, and $cost(\pi')\leq cost(\pi)$ \cite{Imai_15}.\\
We can add this constraint as follows:
$$_{(P5)}\quad x_a+x_b\leq1\qquad\forall a,b\in A^+,\,s.t.\;a\mbox{ is an inverse action of }b$$

\subsection{Efficiency concerns}
Section $(2.3.4)$ is one of the most effective preprocessing technique among the ones we presented; however, a naive algorithm that would require $O(|A^+|^2)$ steps, might require too much time for some of the most demanding instances.
\begin{algorithm}[h]
    \caption{Naive dominated actions extraction}
    \begin{algorithmic}
        \State $D\gets\emptyset\qquad\qquad$\# D is the set of dominated actions
        \For{$a\in A^+$}
            \For{$b\in A^+$}
                \If{$(\mbox{fadd}(b)\subseteq fadd(a)$ and $\forall p\in pre(a),\;p\mbox{ is a fact landmark for }b$ and $cost(b)\geq cost(a))$}
                    \State $D\gets D\cup\{b\}$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

This concern extends also to section $(2.3.5)$, therefore we felt the need to devise a data structure to speedup the filtering among actions. To explain how this data structure works, we will explain it using the example of the dominated actions extraction.\\
The problem lies in the inner loop: we, currently, are looking blindly among all actions for an action $b$ that is dominated by $a$; we need a way to filter among all actions, a smaller set of actions that contains all, but not necessarily only, the actions dominated by $a$. Luckily we know that if $\mbox{fadd}(b)\not\subseteq\mbox{fadd}(a)$, $b$ is not dominated by $a$, hence all those actions can be removed. We use a binary tree to store actions in a way that we can efficiently get all but those actions.\\
To add an action $a$ to the tree $T$ ($T.$insert($a$,\,fadd($a$))):
\begin{enumerate}
    \item Start from the root
    \item For each $p\in P$, if $p\not\in \mbox{fadd}(a)$ we go to the left node, otherwise we go to the right node
    \item Once we reached a leaf, we append $a$ to a list in that leaf
\end{enumerate}
Then, given an action $a$, if we need to find all actions $b$ that satisfy $\mbox{fadd}(b)\subseteq\mbox{fadd}(a)$ ($T$.search(fadd($a$))):
\begin{enumerate}
    \item Start from the root
    \item For each $p\in P$, if $p\not\in \mbox{fadd(a)}$ we go to the left node, otherwise we expand both
    \item At the end we'll have a list of leaves we reached: all actions stored in the lists of those leaves, are all the actions $b$ that satisfy $\mbox{fadd}(b)\subseteq\mbox{fadd}(a)$
\end{enumerate}
The proof of this last statement lies on the construction of the tree: consider a generic $p\in P$, if $p\in\mbox{fadd}(a)$ then fadd($b$) might have or not have $p$, so we branch our search; if $p\not\in\mbox{fadd}(a)$, then we are interested only in actions $b$ that satisfy $p\not\in\mbox{fadd}(b)$, hence we can just go left without branching, since all actions that didn't have $p$ among its first achievers, were inserted in the tree going left at this step.
\begin{algorithm}[h]
    \caption{Improved dominated actions extraction}
    \begin{algorithmic}
        \State $D\gets\emptyset\qquad\qquad$\# D is the set of dominated actions
        \State $T\gets$ empty binary tree
        \For{$a\in A^+$}
            \State $T$.insert($a$,\,fadd($a$))
        \EndFor
        \For{$a\in A^+$}
            \For{$b\in T.\mbox{search(fadd}(a))$}
                \If{$(\forall p\in pre(a),\;p\mbox{ is a fact landmark for }b$ and $cost(b)\geq cost(a))$}
                    \State $D\gets D\cup\{b\}$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

This technique, with some further optimizations, led to a huge performance increase in our dominated and inverse actions extraction: this is due to the fact that, usually, actions don't have many positive effects, hence we don't have many branching in our search; this means that we have an efficient search for possible dominated actions, and a smaller number of iterations in the inner cycle. This technique, however, is much less efficient for example when looking for all actions that can be applied from a specific state $s$ (using pre($a$) for the insert part and $s$ for the search part), since a state might contain many atoms, increasing exponentially the number of branchings needed to complete the search. This issue will be tackled in chapter $3$, where we will compute a sub-optimal plan to provide as a warm-start to our MIP solver and we will need an efficient way of retrieving applicable actions.

We define additional sets to refer to the atoms/actions eliminated/fixed by this preprocessing: 
\begin{gather*}
    P^e=\{p\in P,\,s.t.\;x_p\mbox{ has been set to }0\},\;P^f=\{p\in P,\,s.t.\;x_p\mbox{ has been set to }1\}\\
    A^{+,e}=\{a\in A^+,\,s.t.\;x_a\mbox{ has been set to }0\},\;A^{+,f}=\{a\in A^+,\,s.t.\;x_a\mbox{ has been set to }1\}
\end{gather*}

By adding constraints $(P1)$-$(P5)$ to $\tl$ and $(P1)$-$(P4)$ to $\ve$, we obtain $\tle$ and $\vee$ respectively. We don't add $(P5$) to $\ve$ since $(P5)$ is included in $(C7)$, from our vertex elimination acyclicity modeling.