A warm start in Mixed Integer Programming refers to providing an initial or partial solution to the solver before it begins its solving process. This can significantly improve performance in several ways:
\begin{enumerate}
    \item Reduced computation time: A good initial solution allows the solver to establish upper bounds early, potentially pruning large portions of the search tree.
    \item Better branch selection: With good incumbent solutions, branching decisions can be more effective as the solver has better bounds.
    \item Improved cut generation: Warm starts can help generate more effective cutting planes early in the solution process.
\end{enumerate}

In this chapter we explore efficient algorithms to compute good primal heuristic solutions, that can be used as warm start to speed up the search.

\section{Greedy heuristic}
When looking for a feasible solution to $\Pi^+$, starting from the initial state, we can simply iteratively look for actions that can be applied on the current state, adding them to the plan until we reach $G$: clearly, whenever we end up in a situation in which no action can be applied, and we didn't reach $G$ yet, we prove the infeasibility of the task $\Pi^+$.
\begin{algorithm}[h]
    \caption{Greedy algorithm}
    \begin{algorithmic}
        \State $S\gets I\qquad\quad\;\;\;$\# current state
        \State $p\gets []\qquad\qquad$\# heuristic solution
        \While{$G\not\subseteq S$}
            \State candidates $\gets\{a\in A^+,\,s.t.\;a\not\in p,\mbox{ and pre(}a)\subseteq S\}$
            \State $a\gets$ greedy choice(candidates)
            \State enqueue $a$ to $p$
            \State $S\gets S\cup\mbox{add}(a)$
        \EndWhile
    \end{algorithmic}
\end{algorithm}

We can immediatelly improve this algorithm by noting that:
\begin{enumerate}
    \item Actions that were fixed during our preprocessing should have the priority
    \item Actions that were eliminated during our preprocessing can be ignored
    \item Actions that only add already achieved atoms can be ignored
\end{enumerate}

\begin{algorithm}[h]
    \caption{Revised greedy algorithm}
    \begin{algorithmic}
        \State $S\gets I\qquad\quad\;\;\;$\# current state
        \State $p\gets []\qquad\qquad$\# heuristic solution
        \While{$G\not\subseteq S$}
            \If{$\exists a\in A^{+,f},\,s.t.\;\mbox{pre}(a)\subseteq S$}
                \State enqueue $a$ to $p$
            \Else
                \State candidates $\gets\{a\in A^+\setminus A^{+,e},\,s.t.\;a\not\in p,\mbox{ and pre(}a)\subseteq S,\mbox{ and add}(a)\not\subseteq S\}$
                \State $a\gets$ greedy choice(candidates)
                \State enqueue $a$ to $p$
            \EndIf
            \State $S\gets S\cup\mbox{add}(a)$
        \EndWhile
    \end{algorithmic}
\end{algorithm}

\subsection{Filtering applicable actions}

We proposed in section $(2.3.6)$ a way to efficiently filter among actions, only those that meet a specific criteria: we already anticipated that said technique won't be helpful for this specific problem, since we would have a large quantity of branches in our search algorithm of the binary tree. Looking among all actions at each step, for candidate actions, is not feasible; instead we can compute iteratively candidate actions based on newly achieved atoms:
\begin{enumerate}
    \item Start by computing, for each atom, the set of actions that have that atom among its preconditions: $$A^+_{pre,p}=\{a\in A^+\setminus A^{+,e},\,s.t.\;p\in\mbox{pre}(a)\}\;\forall p\in P$$
    \item Before the greedy algorithm, initialize the candidates list as the set of actions with no preconditions; since the initial state is empty, those are the initial candidates:
    $$\mbox{candidates}=\{a\in A^+\setminus A^{+,e},\,s.t.\;\mbox{pre}(a)=\emptyset\}$$
    \item After making the greedy choice, update the candidates by expanding that list with actions that have among its preconditions, newly achieved atoms: by using $A^+_{pre,p}$ for each newly added atom, we are looking only among possible new candidates, skipping most of the unreachable actions.
\end{enumerate}

\begin{algorithm}[h]
    \caption{Efficient greedy algorithm}
    \begin{algorithmic}
        \State $S\gets I\qquad\quad\;\;\;$\# current state
        \State $p\gets []\qquad\qquad$\# heuristic solution
        \State candidates $\gets\{a\in A^+\setminus A^{+,e},\,s.t.\;\mbox{pre}(a)=\emptyset\}$
        \State $A^+_{pre,p}\gets\{a\in A^+\setminus A^{+,e},\,s.t.\;p\in\mbox{pre}(a)\}\;\forall p\in P$
        \While{$G\not\subseteq S$}
            \If{$\exists a\in A^{+,f},\,s.t.\;\mbox{pre}(a)\subseteq S$}
                \State enqueue $a$ to $p$
            \Else
                \State $a\gets$ greedy choice(candidates)
                \State enqueue $a$ to $p$
            \EndIf
            \For{$p\in\mbox{add}(a)\setminus S$}
                \For{$a'\in A^+_{pre,p}$}
                    \If{pre($a'$)$\subseteq(S\cup\mbox{add}(a))$ and $a'\not\in$ candidates}
                        \State candidates $\gets$ candidates $\cup$ $\{a'\}$
                    \EndIf
                \EndFor
            \EndFor
            \State $S\gets S\cup\mbox{add}(a)$
            \For{$a'\in$ candidates}
                \If{add($a$)$\subseteq S$}
                    \State remove $a'$ from candidates
                \EndIf
            \EndFor
        \EndWhile
    \end{algorithmic}
\end{algorithm}

\section{Naive greedy choice}
The naive greedy choice will be to choose the action with lowest cost among the candidates:
$$\mbox{greedy choice}_c\mbox{(candidates)}=argmin_a\{cost(a),\;\forall a\in\mbox{candidates}\}$$
However there's another possible greedy choice, choosing the action that adds the highest number of new atoms:
$$\mbox{greedy choice}_a\mbox{(candidates},S)=argmax_a\{|add(a)\setminus S|,\;\forall a\in\mbox{candidates}\}$$
We can combine those two into a single improved greedy choice:
$$\mbox{greedy choice}_{c\times a}\mbox{(candidates},S)=argmin_a\{{cost(a)\over|add(a)\setminus S|},\;\forall a\in\mbox{candidates}\}$$

\section{Hmax and Hadd estimators}

Computing $\hplus$ is NP-equivalent, hence techniques to estimate it have been proposed: $\hmax$ and $\hadd$ \cite{Bonet_01} aim to estimate the cost of achieving the goal atoms and then set their values to a combination of those costs.
Suppose we are in the state $S$ and we aim to reach $G$:
$$\hmax_S(p)=\begin{cases}
    0&\mbox{if }p\in S\\
    \min_{a\in A^+_p}\{cost(a)+\max_{q\in pre(a)}\{\hmax_S(q)\}\}&\mbox{otherwise}
\end{cases}$$
$$\hadd_S(p)=\begin{cases}
    0&\mbox{if }p\in S\\
    \min_{a\in A^+_p}\{cost(a)+\sum_{q\in pre(a)}\{\hadd_S(q)\}\}&\mbox{otherwise}
\end{cases}$$
with $A^+_p=\{a\in A^+\setminus A^{+,e},\,s.t.\;p\in\mbox{add}(a)\}$, and
$$\hmax_S=\max_{p\in G}\{\hmax_S(p)\},\qquad\hadd_S=\sum_{p\in G}\hadd_S(p)$$
$\hmax\equiv\hmax_I$ is considering the ``cost'' of the ``most expensive'' atom in the goal state, while $\hadd\equiv\hadd_I$ is isolating each atom in the goal state, and adding up all their ``costs'': we integrated these two estimators in our greedy algorithm:
\begin{gather*}
    \mbox{greedy choice}_{\hmax}(\mbox{candidates}, S)=argmin_a\{\hmax_{S'},\;S'=S\cup\mbox{add}(a),\,\forall a\in\mbox{candidates}\}\\
    \mbox{greedy choice}_{\hadd}(\mbox{candidates}, S)=argmin_a\{\hadd_{S'},\;S'=S\cup\mbox{add}(a),\,\forall a\in\mbox{candidates}\}
\end{gather*}

Computing from scratch $\hmax_{S'}$ and $\hadd_{S'}$ for each $a\in$ candidates would require too much time, so we integrated in our greedy algorithm, an iterative computation of $\hmax$ and $\hadd$, which reuses past iteration's values of $\hmax$ and $\hadd$ and updates only necessary ones, using a trail to keep track of the changes that need to be reverted.